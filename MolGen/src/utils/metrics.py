from rdkit import Chem
from rdkit.Chem import QED, rdMolDescriptors, Crippen


def calc_novelty(train_set_mols: List[str], gen_mols: List[str]) -> float:
    """
    Calculates the novelty score of the generated molecule list.
    the novelty score is the ratio between the amount of molecules that aren't in the train set
    and the size of the entire generate molecule list.

    |gen_mols - train_set_mols|
    ---------------------------
           |gen_mols|

    Args:
        train_set_mols:
            List of molecules used to train the model, molecules are in SMILES form.

        gen_mols:
            List of molecuels that were generated by the model, molecules are in SMILES form.

    Returns:
        The novelty score of the generated set.
        novlty score ranges between 0 and 1.
    """ 
    new_molecuels = set(gen_mols) - set(train_set_mols)

    return len(new_molecules) / len(gen_mols)

def calc_diversity(gen_mols: List[str]) -> float:
    """
    Calculates the diversity of the generate molecule list.
    The diversity is the number of unique molecules in the generated list.

    |unqiue(gen_mols)|
    ------------------
        |gen_mols|

    Args:
        gen_mols:
            List of molecules that werte generated by the model, molecules are in SMILES form.

    Returns:
        The diversity score of the generated set.
        diversity score ranges between 0 and 1.
    """ 
    return len(set(gen_mols)) / len(gen_mols)

def calc_logp(mol: Chem.rdchem.Mol) -> float:
    """
    Calculates the logP for a given molecule.

    Args:
        mol:
            An rdkit molecule object.

    Returns:
        the molecule log p which is his the log ratio between
        water solubility and octanol solubility.
    """
    log_p = Crippen.MolLogP(mol)

    return log_p



def calc_qed(mol: Chem.rdchem.Mol) -> float:
    """
    Calculates the quantitative estimation of drug-likeness of a given molecule.

    Args:
        mol:
            An rdkit molecule object.

    Returns:
        the molecule qed value which estimate how much this molecule
        resemebles a drug.
    """
    qed = QED.qed(mol)

    return qed


def calc_sas(mol: Chem.rdchem.Mol) -> float:
    """
    Calculates the Synthetic Accessiblity Score (SAS) of a drug-like molecule
    based on the molecular compelxity and fragment contribution.
    
    code taken from: https://github.com/rdkit/rdkit/blob/master/Contrib/SA_Score/sascorer.py

    Args:
        A rdkit molecule object.

    Returns:
        The SAS score of a given molecule.

    Raises

    """ 
    fp = rdMolDescriptors.GetMorganFingerprint(m, 2)  # <- 2 is the *radius* of the circular fingerprint
    fps = fp.GetNonzeroElements()
    score1 = 0.
    nf = 0
    for bitId, v in fps.items():
        nf += v
        sfp = bitId
        score1 += _fscores.get(sfp, -4) * v
    score1 /= nf

    # features score
    nAtoms = m.GetNumAtoms()
    nChiralCenters = len(Chem.FindMolChiralCenters(m, includeUnassigned=True))
    ri = m.GetRingInfo()
    nBridgeheads, nSpiro = numBridgeheadsAndSpiro(m, ri)
    nMacrocycles = 0
    for x in ri.AtomRings():
        if len(x) > 8:
            nMacrocycles += 1

    sizePenalty = nAtoms**1.005 - nAtoms
    stereoPenalty = math.log10(nChiralCenters + 1)
    spiroPenalty = math.log10(nSpiro + 1)
    bridgePenalty = math.log10(nBridgeheads + 1)
    macrocyclePenalty = 0.

    # ---------------------------------------
    # This differs from the paper, which defines:
    #  macrocyclePenalty = math.log10(nMacrocycles+1)
    # This form generates better results when 2 or more macrocycles are present

    if nMacrocycles > 0:
    macrocyclePenalty = math.log10(2)

    score2 = 0. - sizePenalty - stereoPenalty - spiroPenalty - bridgePenalty - macrocyclePenalty

    # correction for the fingerprint density
    # not in the original publication, added in version 1.1
    # to make highly symmetrical molecules easier to synthetise
    score3 = 0.
    if nAtoms > len(fps):
        score3 = math.log(float(nAtoms) / len(fps)) * .5

    sascore = score1 + score2 + score3

    # need to transform "raw" value into scale between 1 and 10
    min = -4.0
    max = 2.5
    sascore = 11. - (sascore - min + 1) / (max - min) * 9.

    # smooth the 10-end
    if sascore > 8.:
        sascore = 8. + math.log(sascore + 1. - 9.)
    if sascore > 10.:
        sascore = 10.0
    elif sascore < 1.:
        sascore = 1.0

    return sascore
