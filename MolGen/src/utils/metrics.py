import math
import os
import pickle
from typing import List

from rdkit import Chem
from rdkit.Chem import QED, rdMolDescriptors, Crippen


def calc_novelty(train_set_path: str, generated_molecules: List[str]) -> float:
    """
    Calculates the novelty score of the generated molecule list.
    the novelty score is the ratio between the amount of molecules that aren't in the train set
    and the size of the entire generate molecule list.

    |gen_molecules - train_set_molecules|
    ---------------------------
           |gen_molecules|

    Args:
        train_set_path:
            Path to the location of the data used to train the model with.

        generated_molecules:
            List of molecuels that were generated by the model, molecules are in SMILES form.

    Returns:
        The novelty score of the generated set.
        novlty score ranges between 0 and 1.
    """ 
    paths = []
    if os.path.isdir(train_set_path):
        data_paths = os.listdir(train_set_path)
        for path in data_paths:
            full_path = os.path.join(train_set_path, path)
            paths.append(full_path)
    else:
        paths.append(train_set_path)
    
    exists = 0
    for path in paths:
        with open(path, 'r') as f:
            for line in f:
                if line.strip() in generated_molecules:
                    exists += 1
    

    new_molecules = len(generated_molecules) - exists

    return new_molecules / len(generated_molecules)

def calc_diversity(gen_molecules: List[str]) -> float:
    """
    Calculates the diversity of the generate molecule list.
    The diversity is the number of unique molecules in the generated list.

    |unqiue(gen_molecules)|
    ------------------
        |gen_molecules|

    Args:
        gen_molecules:
            List of molecules that werte generated by the model, molecules are in SMILES form.

    Returns:
        The diversity score of the generated set.
        diversity score ranges between 0 and 1.
    """ 
    return len(set(gen_molecules)) / len(gen_molecules)

def calc_logp(mol: Chem.rdchem.Mol) -> float:
    """
    Calculates the logP for a given molecule.

    Args:
        mol:
            An rdkit molecule object.

    Returns:
        the molecule log p which is his the log ratio between
        water solubility and octanol solubility.
    """
    log_p = Crippen.MolLogP(mol)

    return log_p



def calc_qed(mol: Chem.rdchem.Mol) -> float:
    """
    Calculates the quantitative estimation of drug-likeness of a given molecule.

    Args:
        mol:
            An rdkit molecule object.

    Returns:
        the molecule qed value which estimate how much this molecule
        resemebles a drug.
    """
    qed = QED.qed(mol)

    return qed

def numBridgeheadsAndSpiro(mol, ri=None):
    nSpiro = rdMolDescriptors.CalcNumSpiroAtoms(mol)
    nBridgehead = rdMolDescriptors.CalcNumBridgeheadAtoms(mol)
    return nBridgehead, nSpiro

def calc_sas(mol: Chem.rdchem.Mol) -> float:
    """
    Calculates the Synthetic Accessiblity Score (SAS) of a drug-like molecule
    based on the molecular compelxity and fragment contribution.
    
    code taken from: https://github.com/rdkit/rdkit/blob/master/Contrib/SA_Score/sascorer.py

    Args:
        A rdkit molecule object.

    Returns:
        The SAS score of a given molecule.

    Raises

    """ 
    with open('../data/pickles/SA_score.pkl', 'rb') as f:
        data = pickle.load(f)
    outDict = {}
    for i in data:
        for j in range(1, len(i)):
            outDict[i[j]] = float(i[0])
    _fscores = outDict

    fp = rdMolDescriptors.GetMorganFingerprint(mol, 2)  # <- 2 is the *radius* of the circular fingerprint
    fps = fp.GetNonzeroElements()
    score1 = 0.
    nf = 0
    for bitId, v in fps.items():
        nf += v
        sfp = bitId
        score1 += _fscores.get(sfp, -4) * v
    score1 /= nf

    # features score
    nAtoms = mol.GetNumAtoms()
    nChiralCenters = len(Chem.FindMolChiralCenters(mol, includeUnassigned=True))
    ri = mol.GetRingInfo()
    nBridgeheads, nSpiro = numBridgeheadsAndSpiro(mol, ri)
    nMacrocycles = 0
    for x in ri.AtomRings():
        if len(x) > 8:
            nMacrocycles += 1

    sizePenalty = nAtoms**1.005 - nAtoms
    stereoPenalty = math.log10(nChiralCenters + 1)
    spiroPenalty = math.log10(nSpiro + 1)
    bridgePenalty = math.log10(nBridgeheads + 1)
    macrocyclePenalty = 0.

    # ---------------------------------------
    # This differs from the paper, which defines:
    #  macrocyclePenalty = math.log10(nMacrocycles+1)
    # This form generates better results when 2 or more macrocycles are present

    if nMacrocycles > 0:
        macrocyclePenalty = math.log10(2)

    score2 = 0. - sizePenalty - stereoPenalty - spiroPenalty - bridgePenalty - macrocyclePenalty

    # correction for the fingerprint density
    # not in the original publication, added in version 1.1
    # to make highly symmetrical molecules easier to synthetise
    score3 = 0.
    if nAtoms > len(fps):
        score3 = math.log(float(nAtoms) / len(fps)) * .5

    sascore = score1 + score2 + score3

    # need to transform "raw" value into scale between 1 and 10
    min = -4.0
    max = 2.5
    sascore = 11. - (sascore - min + 1) / (max - min) * 9.

    # smooth the 10-end
    if sascore > 8.:
        sascore = 8. + math.log(sascore + 1. - 9.)
    if sascore > 10.:
        sascore = 10.0
    elif sascore < 1.:
        sascore = 1.0

    return sascore

def calc_valid_molecules(molecules: List[str]) -> float:
    valid_molecules = [mol for mol in molecules if Chem.MolFromSmiles(mol) is not None]

    return len(valid_molecules) / len(molecules)
